# 프로세스
- 프로그램: 하드디스크 같은 저장장치에 보관되어 있는 실행코드 (프로세스 - PCB)
- 프로세스: 프로그램이 메모리에 적재되어 실행되고 있는 상태 (프로그램 + PCB)

## 프로세스 - PCB
- 프로세스 제어 블록(Process Control Block): 프로세스의 상태를 나타내는 정보를 담고 있는 자료구조로 메모리에 운영체제 영역에 저장된다.
  - 프로세스 구분자(PID): 프로세스를 구분하기 위한 고유한 ID
  - 메모리 관련 정보: 프로세스가 사용하는 메모리 영역의 정보 (프로세스가 메모리에서 어느 범위부터 어느 범위까지 사용하는지)
  - 각종 중간값: 컨텍스트 스위칭 시 복구 또는 실행해야 되는 기준이 되는 값들

## 프로세스 - 상태
- 생성 상태: 프로세스가 메모리에 올라와 실행 준비를 완료한 상태다. 이때 PCB가 생성된다.
- 준비 상태: 프로세스가 CPU를 할당받기 위해 기다리는 상태다.
- 실행 상태: 프로세스가 주어진 시간 동안 CPU를 할당받아 명령어를 실행하는 상태다.
- 완료 상태: 프로세스의 실행이 종료된 상태다. 이때 PCB가 소멸된다.
___
- 대기 상태: 인터럽트 시스템에서 프로세스가 입출력을 요구하면 CPU가 직접 데이터를 가져오지 않고 입출력 관리자에게 명령을 내린다. 이 상태에서
프로세스는 요청한 작업이 끝날 때까지 다음 작업을 할 수 없다. 따라서 CPU는 아무 작업도 하지 않고 기다리게 되어 효율성이 떨어지는데, 이때 프로세스를 `대기 상태`
로 두어서 CPU 스케쥴러는 준비 상태에 있는 다른 프로세스에게 CPU를 할당할 수 있도록 한다.

## 프로세스 - 상태 디테일
- 생성 상태: 프로그램이 메모리에 올라오고 운영체제로부터 프로세스 제어 블록을 할당받은 상태, 바로 실행되는 것이 아니라 준비 상태에서 자기 순서를 기다린다. 프로세스
제어 블록도 같이 준비 상태로 옮겨진다.
- 준비 상태: 실행 대기 중인 모든 프로세스가 자기 순서를 기다리는 상태다. 프로세스 제어 블록도 같이 준비 큐에서 기다리며 CPU 스케쥴러에 의해 관리된다. 준비 큐는
1개가 아니라 여러 개가 있을 수 있다. CPU 스케쥴러가 어떤 프로세스 제어 블록을 선택하는 작업은 dispatch(PID) 명령으로 처리하는데 이 멸령어를 실행하면 해당 프로세스가
준비 상태에서 실행 상태로 바뀌어 작업이 이루어진다.
- 실행 상태: 프로세스가 CPU를 할당받아 실행되는 상태다. 준비 상태에 있던 프로세스 중 실행 상태에 들어가는 프로세스는 CPU의 개수 만큼이다. 실행 상태에 있는
프로세스는 자신에게 주어진 시간, 즉 타임 슬라이스 동안만 작업할 수 있다. 그 시간을 다 사용하면 timeout(PID)가 실행되고 준비 상태로 돌아간다. 이때 프로세스 제어 블록도 같이
준비 큐로 돌아간다. 만약 실행 동안 작업이 완료되면 exit(PID)가 실행되어 프로세스가 종료된다.
- 대기 상태: 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태를 'wait status'라고도 한다. 대기 상태는 작업의 효율을 위해 만들어진 것으로
대기 상태의 프로세스는 입출력장치별로 마련된 큐에서 기다린다. 입출력이 완료되면 인터럽트가 발생되고, 대기 상태에 있는 프로세스 중 해당 인터럽트로 깨울 프로세스를 찾는데
이것이 wakeup(PID) 명령이다. 이 명령을 실행하면 해당 프로세스가 준비 상태로 돌아간다. 
- 완료 상태: 프로세스가 종료되는 상태다. 완료 상태에서는 코드와 사용했던 데이터 등을 메모리에서 삭제하고 프로세스 제어 블록을 폐기한다. 정상적인 종료는
exit()명령으로 처리하고, 비정상적인 종료는 디버깅을 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮긴다. 이를 코어 덤프라고 한다.

## 프로세스 - 휴식 상태, 보류 상태
대부분의 프로세스는 위 5개의 상태인 활성 상태로 동작하지만, 휴식 상태와 보류 상태로 동작하는 프로세스도 있다.
- 휴식 상태: 프로세스가 작업을 일시적으로 쉬고 있는 상태다. 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 
재시작할 수 있다. 
- 보류 상태: 프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있다. 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역에 보관된다. 
보류 상태와 휴식 상태를 구분하자면, 보류 상태는 스왑 영역에 있는 상태이고 휴식 상태는 프로세스가 메모리에 있으나 멈춘 상태이다. 다음은 프로세스가 보류 상태가 되는 경우다.
  - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
  - 프로그램에 오류가 있어서 실행을 미루어야 할 때
  - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
  - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때

## 프로세스 - 구조
- 코드 영역: 프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 한다. 프로그래머가 작성한 프로그램은 코드 영역에 탑재되며 탑재된 코드는 읽기 전용으로 처리된다.
- 데이터 영역: 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳이다. 상수들도 데이터 영역에 저장된다.
- 스택 영역: 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳이다. 예를 들어 프로세스 내에서 함수를 호출하면 함수를 수행하고 원래 프로그램으로 되돌아올 위치를 이 영역에
저장한다. 
- 예: 워드프로세서 프로그램을 실행하면 이 프로그램은 코드 영역에 탑재되고, 워드프로세서로 편집 중인 문서는 데이터 영역에 탑재된다. 또한 운영체제가 워드프로세서를 작동하기 위해
사용하는 각종 부가 데이터는 스택 영역에서 관리한다.

## 프로세스 - 구조 예시
- 예시 코드
```c
main() {
  int da=2, fa=3;
  printf("add %d \n", da+fa);
  exit();
```

- 코드 영역
```c
main() {
  int da=2, fa=3;
  printf("add %d \n", da+fa);
  exit();
```

- 데이터 영역
```c
int da=2, fa=3;
```

- 스택 영역
```
Return address 180
```

## 프로세스 - fork 시스템 콜
- fork() 시스템 콜을 사용하면 실행 중인 프로세스로부터 새로운 프로세스를 복사한다. 예를 들어 크롬 탭을 사용하다가 새로운 탭을 만들면 이것은 크롬을 새로 실행하는 것이 아니라
현재의 크롬 프로세스를 복사한 것이다. 프로세스를 복사할 때 기존의 프로세스는 부모 프로세스가 되고 새로운 프로세스는 자식 프로세스가 된다.
- 프로세스를 복사하는 이유는 새로 생성하는 것보다 기존의 프로세스를 복사하는 것이 더 빠르기 때문이다.
- 복사 됐을 때 PCB:
  - 기존 프로세스 P1, P1으로부터 새로 생성된 자식 프로세스 P2
  - P1의 PCB: PID = 326 / PPID: 123 / CPID: 368
  - P2의 PCB: PID = 368 / PPID: 326 / CPID: -1 (자식 프로세스가 없다는 뜻)
- fork() 시스템 콜의 장점
  - 프로세스를 복사하는 것은 새로운 프로세스를 생성하는 것보다 빠르다: 하드디스크로부터 프로그램을 새로 가져오지 않고 메모리에 있는 프로그램을 그대로 복사하기 때문이다.
  - 추가 작업 없이 자원을 상속할 수 있다: 부모 프로세서가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있다.
  - 시스템 관리를 효율적으로 할 수 있다: 부모 프로세스와 자식 프로세스는 PID로 연결되어 있기 때문에 자식 프로세스를 종료하면 자식이 사용하던 자원을
  부모 프로세스가 정리할 수 있다. 프로세스를 종료하면 프로세스가 사용하던 자원들을 잘 정리해야 하는데 이러한 정리를 부모 프로세스에게 맡길 수 있어서 시스템이 효율적으로 관리된다.

## 프로세스 - exec 시스템 콜
exec() 시스템 콜은 기존의 프로세스를 새로운 프로세스로 전환하는 함수다. 즉, 기존의 프로세스가 사용하던 코드, 데이터, 스택 등을 새로운 프로세스로 덮어쓴다. exec()를
사용하는 이유는 프로세스의 구조체를 재활용하기 위함이다. 새로운 프로세스를 만들려면 PCB를 새로 만들고 메모리 공간을 확보하는 작업 등이 필요한데 exec()를 사용하면
이미 만들어진 PCB, 메모리 영역, 부모-자식 관계 등을 그대로 사용할 수 있어 편리하다.
- 동작 과정: exec() 시스템 콜을 사용하면 코드 영역에 있는 기존 내용을 지우고 새로운 코드로 바꾼다. 데이터 영역을 새로운 변수로 채우고 스택 영역이 리셋된다.
PCB의 내용 중 PID, PPID, CPID, 메모리 관련 사항 등은 변하지 않지만 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 리셋된다.

## 프로세스 계층 구조 (유닉스 예시)
- 유닉스에서 커널이 처음 메모리에 올라와 부팅이 되면 커널 관련 프로세스를 여러 개 만드는데, 그중 init 프로세스는 전체 프로세스의 출발점이 된다.
운영체제는 프로세스를 효율적으로 관리하기 위해 init 프로세스를 루트로 나머지 프로세스를 자식으로 만든다.
- 계층 구조의 장점: 
  - 여러 작업의 동시 처리: login 프로세스는 사용자의 로그인을 처리한다. 만약 사용자 3명이 동시에 컴퓨터에 접속한다면 동시에 3명을 처리해야 하는데
  login 프로세스는 한 번에 1명만 처리할 수 있기 때문에 유닉스 운영체제는 login 프로세스를 3개 만들어서 동시에 3명을 처리한다. login 프로세스를 통과하고 나면
  shell 프로세스가 필요한데, shell 프로세스는 처리된 login 프로세스에서 exec() 시스템 콜로 생성된다. 이유는 shell 프로세스를 따로 만들면 비용이 크기 때문이다.
  - 용이한 자원 회수: 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리 하기가 수월하다. 작업을 마쳐서 그 프로세스가 사용하던 자원을 회수 할 때
  특히 편리하다. 만약 모든 프로세스가 독립적으로 만들어지면 프로세스가 종료될 때마다 운영체제가 직접 자원을 회수해야 하지만 계층 구조로 만들면 부모 프로세스가 자식 프로세스의 자원을
  회수할 수 있다.
- 고아 프로세스: 비정상적으로 부모 프로세스 혹은 자식 프로세스가 종료되면 순서대로 좀비 프로세스, 고아 프로세스가 된다. 이는 컴퓨터의 효율적인 운영에 방해가 되기 때문에
운영체제는 주기적으로 반환되지 못한 자원을 회수하는 작업을 해야 한다. 