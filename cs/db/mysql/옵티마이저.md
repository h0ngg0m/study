# 옵티마이저
MySQL 서버로 요청된 쿼리는 결과는 동일하지만 내부적으로 그 결과를 만들어내는 방법은 매우 다양하다.
이런 다양한 방법 중에서 어떤 방법이 최적이고 최소의 비용이 소모될지 결정해야 한다. 이때 최적의 실행 계획을 수립하는 작업을 옵티마이저가 수행한다.

## 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

첫 번째 단계를 파싱이라고 하며, MySQL 서버의 SQL 파서라는 모듈로 처리한다. SQL 문법이 잘못됐으면 이 단계에서 걸러진다. 또한 이 단계에서
SQL 파스 트리가 만들어진다. MySQL 서버는 SQL 문장 그 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.

두 번째 단계는 첫 번째 단계에서 만들어진 SQL 파스 트리를 참조하면서 다음과 같은 내용을 처리한다.
- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

두 번째 단계는 '최적화 및 실행 계획 수립' 단계이며, MySQL 서버의 `옵티마이저`에서 처리한다. 또한 두 번째 단계가 완료되면 쿼리의 '실행 계획'이 만들어진다.

## 옵티마이저의 종류
- 규칙 기반 최적화: 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
- 비용 기반 최적화(현재 대부분의 DBMS가 사용하는 방식): 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의
예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.

## 정렬 방법
레코드 1~2건을 가져오는 쿼리를 제외하면 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다.

- 인덱스 이용
  - 장점: INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다
  - 단점: INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 많이 필요하다.
- Filesort 이용
  - 장점: 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다.
  - 단점: 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.

## 소트 버퍼
MySQL 서버는 정렬 작업을 위해 메모리를 할당받는다. 이때 사용하는 메모리 영역을 소트 버퍼라고 한다.
소트 버퍼는 정렬이 필요한 경우에만 할당되며. 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은
sort_buffer_size 시스템 변수로 제어할 수 있다. 

## 싱글 패스 정렬 방식
소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.

## 투 패스 정렬 방식
정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 컬럼을 가져오는
정렬 방식으로, 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식이다.

MySQL의 예전 정렬 방식인 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 상당히 불합리하지만, 새로운 정렬 방식인 싱글 패스는 이러한 불합리가 없다.
하지만 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요하다. 즉, 대략 128KB의 정렬 버퍼를 사용한다면 이 쿼리는 투 패스 정렬 방식에서는 대략 7,000건의
레코드를 정렬할 수 있지만 싱글 패스 정렬 방식에서는 그것의 반 정도밖에 정렬할 수 없다.

## 정렬 처리 방법
쿼리에 ORDER BY가 포함되어 있으면 MySQL 서버는 다음 3가지 방법 중 하나로 정렬을 처리한다. 일반적으로 아래 쪽으로 갈수록 처리 속도는 떨어진다.
<table>
<tr>
<th>
정렬 처리 방법
</th>
<td>
실행 계획의 Extra 컬럼 내용
</td>
</tr>
<tr>
<td>
인덱스를 사용한 정렬
</td>
<td>
별도 표기 없음
</td>
</tr>
<tr>
<td>
조인에서 드라이빙 테이블만 정렬
</td>
<td>
"Using filesort" 메시지가 표시됨
</td>
</tr>
<tr>
<td>
조인에서 조인 결과를 임시 테이블로 저장 후 정렬
</td>
<td>
"Using temporary; Using filesort" 메시지가 표시됨
</td>
</tr>
</table>

## 인덱스를 이용한 정렬
인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY의 순서대로 생선된 인덱스가 있어야 한다.
또한 WHERE 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다. 

인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다. 실제로 MySQL 엔진에서 별도의
정렬을 위한 추가 작업을 수생하지는 않는다. 이처럼 인덱스를 사용한 정렬이 가능한 이유는 B-Tree 인덱스가 키 값으로 정렬돼 있기 때문이다.

## 조인의 드라이빙 테이블만 정렬
일반적으로 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어나고, 레코드 하나하나의 크기도 늘어난다. 그래서 조인을 실행하기 전에 첫 번째
테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이 될 것이다. 이 방법으로 정렬이 처리되려면 조인에서 첫 번째로 읽히는 테이블의
컬럼만으로 ORDER BY 절을 작성해야 한다.
```sql
SELECT *
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
  AND e.emp_no BETWEEN 10002 AND 10010
ORDER BY e.last_name;
```
우선 WHERE 절이 다음 2가지 조건을 갖추고 있기 때문에 옵티마이저는 employees 테이블을 드라이빙 테이블로 선택한다.
- WHERE 절의 검색 조건('e.emp_no BETWEEN 10002 AND 10010')은 employees 테이블의 프라이머리 키를 이용해 검색하면 작업량을 줄일 수 있다.
- 드리븐 테이블(salaries 테이블)의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다.

검색은 인덱스 레인지 스캔으로 처리할 수 있지만 ORDER BY 절에 명시된 컬럼은 employees 테이블의 프라이머리 키와 전혀 연관이 없으므로 인덱스를 이용한
정렬은 불가능하다. 그런데 ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블(employees 테이블)에 포함된 컬럼임을 알 수 있다. 옵티마이저는 드라이빙 테이블만
검색해서 정렬을 먼저 수행하고, 그 결과와 salaires 테이블을 조인한 것이다.

1. 인덱스를 이용해 'e.emp_no BETWEEN 10002 AND 10010' 조건을 만족하는 9건을 검색한다.
2. 검색 결과를 last_name 컬럼으로 정렬을 수행(FIlesort)
3. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해 86건의 최종 결과를 가져옴

## 임시 테이블을 이용한 정렬
쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 SELECT해서 정렬하는 경우라면 임시 테이블이 필요하지 않다.
하지만 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다. 위 '조인의 드라이빙 테이블만 정렬'예시 에서는 2개 이상의 테이블이
조인되면서 정렬이 실행되지만 임시 테이블을 사용하지 않는다. 하지만 그 외 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.
이 방법은 3가지 방법 중에 정렬해야할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법이다.
```sql
SELECT *
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
  AND e.emp_no BETWEEN 10002 AND 10010
ORDER BY s.salary;
```
이번 쿼리에서는 ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블이 아니라 드리븐 테이블에 있는 컬럼이다. 즉 정렬이 수행되기 전에 salaries 테이블을 먼저 읽어야 하므로
이 쿼리는 조인된 데이터를 가지고 정렬할 수밖에 없다. (조인을 먼저하고 조인된 결과를 임시 테이블에 저장 후 정렬하는 방식)
